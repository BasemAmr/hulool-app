// src/components/dashboard/DashboardClientCard.tsx
import { useTranslation } from 'react-i18next';
import { Link } from 'react-router-dom';
import { useQueryClient } from '@tanstack/react-query';
import { useModalStore } from '../../stores/modalStore';
import { useDrawerStore } from '../../stores/drawerStore';
import { useToast } from '../../hooks/useToast';
import { useDeferTask, useResumeTask, useUpdateTask } from '../../queries/taskQueries';
import { useGetEmployeesForSelection } from '../../queries/employeeQueries';
import type { Task } from '../../api/types';
import { formatDate } from '../../utils/dateUtils';
import { Dropdown } from 'react-bootstrap';
import {
  Receipt,
  Check,
  Pause,
  Play,
  ListChecks,
  MoreVertical,
  AlertTriangle,
  Eye,
  MessageSquare,
  UserPlus,
} from 'lucide-react';
import WhatsAppIcon from '../../assets/images/whats.svg';
import GoogleDriveIcon from '../../assets/images/googe_drive.svg';
import type { ClientWithTasksAndStats } from '../../queries/dashboardQueries';
import { useEffect, useRef, useState } from 'react';

interface DashboardClientCardProps {
  data: ClientWithTasksAndStats;
  index?: number;
  alternatingColors: string[];
  onAssign?: (task: Task) => void;
}

const hexToRgba = (hex: string, opacity: number): string => {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${opacity})`;
};

// Updated formatTimeElapsed function for day-based display
const formatDaysElapsed = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diffTime = Math.abs(now.getTime() - date.getTime());
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays === 0) {
    return 'Ø§Ù„ÙŠÙˆÙ…';
  } else if (diffDays === 1) {
    return 'ÙŠÙˆÙ…';
  } else if (diffDays === 2) {
    return 'ÙŠÙˆÙ…ÙŠÙ†';
  } else if (diffDays > 2 && diffDays <= 10) {
    return `${diffDays} Ø£ÙŠØ§Ù…`;
  } else {
    return `${diffDays} ÙŠÙˆÙ…`;
  }
};

const DashboardClientCard = ({ data, index = 0, alternatingColors, onAssign }: DashboardClientCardProps) => {
  const { client, tasks } = data;
  const { t } = useTranslation();
  const openModal = useModalStore(state => state.openModal);
  const { openDrawer } = useDrawerStore();
  const { success, error } = useToast();
  const queryClient = useQueryClient();
  const deferTaskMutation = useDeferTask();
  const resumeTaskMutation = useResumeTask();
  const updateTaskMutation = useUpdateTask();
  const { data: employees = [] } = useGetEmployeesForSelection();
  
  const handleAction = (mutation: any, task: Task, successKey: string, successMessageKey: string, errorKey: string) => {
    mutation.mutate({ id: task.id }, {
      onSuccess: () => {
        success(t(successKey), t(successMessageKey, { taskName: task.task_name || t(`type.${task.type}`) }));
        queryClient.invalidateQueries({ queryKey: ['dashboard', 'clientsWithActiveTasks'] });
      },
      onError: (err: any) => {
        error(t('common.error'), err.message || t(errorKey));
      }
    });
  };

  const handleDefer = (task: Task) => handleAction(deferTaskMutation, task, 'tasks.deferSuccess', 'tasks.deferSuccessMessage', 'tasks.deferError');
  const handleResume = (task: Task) => handleAction(resumeTaskMutation, task, 'tasks.resumeSuccess', 'tasks.resumeSuccessMessage', 'tasks.resumeError');
  const handleComplete = (task: Task) => openModal('taskCompletion', { task });
  const handleShowRequirements = (task: Task) => openModal('requirements', { task });

  // Helper function to check if a user is an employee
  const isUserEmployee = (userId: number | null) => {
    if (!userId) return false;
    return employees.some(emp => emp.user_id === userId);
  };

  // Helper function to check if task should show complete button
  const shouldShowCompleteButton = (task: Task) => {
    // Don't show complete button if task is assigned to an employee
    if (task.assigned_to_id && isUserEmployee(task.assigned_to_id)) {
      return false;
    }
    // TODO: Check if task was created by an employee when backend supports created_by field
    return true;
  };
  const handleAddTask = () => openModal('taskForm', { client });
  const handleAddReceivable = () => openModal('manualReceivable', { client_id: client.id });
  const handleRecordCredit = () => openModal('recordCreditModal', { client });

  const handleToggleUrgentTag = (task: Task) => {
    const isUrgent = task.tags?.some(tag => tag.name === 'Ù‚ØµÙˆÙ‰');
    const urgentTagId = 1;

    const currentTags = Array.isArray(task.tags)
      ? task.tags.map((tag: any) => typeof tag === 'object' ? tag.id.toString() : tag.toString())
      : [];

    let updatedTags: string[];

    if (isUrgent) {
      updatedTags = currentTags.filter(id => id !== urgentTagId.toString());
    } else {
      updatedTags = [...currentTags, urgentTagId.toString()];
    }

    updateTaskMutation.mutate({
      id: task.id,
      taskData: {
        task_name: task.task_name || '',
        type: task.type,
        amount: task.amount,
        start_date: task.start_date,
        end_date: task.end_date || undefined,
        prepaid_amount: task.prepaid_amount,
        notes: task.notes || '',
        tags: updatedTags,
        requirements: task.requirements?.map((req: any) => ({
          id: req.id,
          requirement_text: req.requirement_text,
          is_provided: req.is_provided
        })) || []
      }
    }, {
      onSuccess: () => {
        success(
          isUrgent ? 'ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¹Ù„Ø§Ù…Ø©' : 'ØªÙ…Øª Ø§Ù„Ø¥Ø¶Ø§ÙØ©',
          isUrgent ? 'ØªÙ… Ø¥Ø²Ø§Ù„Ø© Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø¹Ø§Ø¬Ù„ Ù…Ù† Ø§Ù„Ù…Ù‡Ù…Ø©' : 'ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø¹Ø§Ø¬Ù„ Ù„Ù„Ù…Ù‡Ù…Ø©'
        );
        queryClient.invalidateQueries({ queryKey: ['dashboard', 'clientsWithActiveTasks'] });
      },
      onError: (err: any) => {
        error('Ø®Ø·Ø£', err.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø¹Ù„Ø§Ù…Ø© Ø§Ù„Ø¹Ø§Ø¬Ù„');
      }
    });
  };

  // Check if client has urgent tasks
  const isClientUrgent = tasks.some(task => task.tags?.some(tag => tag.name === 'Ù‚ØµÙˆÙ‰'));
  // const hasUrgentTasks = tasks.filter(task => task.tags?.some(tag => tag.name === 'Ù‚ØµÙˆÙ‰')).length > 0;

  // Define stronger alternating colors for headers
  // Color scheme logic
  let headerColor, borderColor, row1Color, row2Color;

  if (isClientUrgent) {
    headerColor = hexToRgba('#dc3545', 0.8); // Red for urgent
    borderColor = hexToRgba('#c82333', 0.6);
    row1Color = hexToRgba('#ffebeb', 0.5);
    row2Color = hexToRgba('#ffe6e6', 0.5);
  } else {
    // Use the stronger alternatingColors as header colors
    const colorIndex = index % 2;
    const baseColor = alternatingColors[colorIndex] || alternatingColors[0];

    // Create stronger color for header (darker version)
    headerColor = baseColor === '#e3f2fd' ? '#1976d2' : // Blue stronger
      baseColor === '#bbdefb' ? '#0d47a1' : // Blue darker
        baseColor === '#fff8e1' ? '#f57f17' : // Yellow stronger  
          baseColor === '#ffecb3' ? '#ff8f00' : // Yellow darker
            baseColor === '#e8f5e8' ? '#2e7d32' : // Green stronger
              baseColor === '#c8e6c9' ? '#1b5e20' : // Green darker
                baseColor === '#f8f9fa' ? '#495057' : // Gray stronger
                  '#343a40'; // Gray darker
    headerColor = hexToRgba(headerColor, 0.5)
    // Create border color (slightly darker than header)
    borderColor = headerColor;

    // Create fainter colors using reduced opacity of the base alternating colors
    row1Color = hexToRgba(alternatingColors[1], 0.3); // Very faint
    row2Color = hexToRgba(alternatingColors[1], 1); // Slightly more visible
  }

  const openGoogleDrive = () => {
    if (client.google_drive_link) {
      window.open(client.google_drive_link, '_blank');
    }
  };

  const openWhatsApp = () => {
    const phoneNumber = client.phone.replace(/[^0-9]/g, '');
    const whatsappUrl = `https://wa.me/+966${phoneNumber}`;
    window.open(whatsappUrl, '_blank');
  };

  const handleEditTask = (task: Task) => openModal('taskForm', { taskToEdit: task, client });

  // Custom hook for dropdown positioning
  const useDropdownPosition = (isOpen: boolean) => {
    const triggerRef = useRef<HTMLButtonElement>(null);
    const [position, setPosition] = useState({ top: 0, left: 0 });

    useEffect(() => {
      if (isOpen && triggerRef.current) {
        const rect = triggerRef.current.getBoundingClientRect();
        setPosition({
          top: rect.bottom + window.scrollY,
          left: rect.left + window.scrollX - 100,
        });
      }
    }, [isOpen]);

    return { triggerRef, position };
  };

  // Header dropdown component
  const HeaderDropdownSection = ({
    handleAddTask,
    handleAddReceivable,
    handleRecordCredit
  }: {
    handleAddTask: () => void;
    handleAddReceivable: () => void;
    handleRecordCredit: () => void;
  }) => {
    const [isOpen, setIsOpen] = useState(false);
    const { triggerRef, position } = useDropdownPosition(isOpen);

    return (
      <div className="dropdown">
        <button
          ref={triggerRef}
          onClick={() => setIsOpen(!isOpen)}
          className="btn btn-outline-light btn-sm p-1 border-0 text-black dropdown-toggle"
          data-bs-toggle="dropdown"
        >
          <MoreVertical size={14} />
        </button>

        <div className={`dropdown-menu ${isOpen ? 'show' : ''}`} style={{
          fontSize: '0.85em',
          direction: 'rtl',
          textAlign: 'right'
        }}>
          <button
            className="dropdown-item text-end"
            onClick={() => {
              handleAddTask();
              setIsOpen(false);
            }}
          >
            <Receipt size={14} className="ms-2" />
            Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø©
          </button>
          <button
            className="dropdown-item text-end"
            onClick={() => {
              handleAddReceivable();
              setIsOpen(false);
            }}
          >
            <Receipt size={14} className="ms-2" />
            Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ­Ù‚
          </button>
          <button
            className="dropdown-item text-end"
            onClick={() => {
              handleRecordCredit();
              setIsOpen(false);
            }}
          >
            <Receipt size={14} className="ms-2" />
            Ø¥Ø¶Ø§ÙØ© Ø¯ÙØ¹Ø©
          </button>
        </div>
      </div>
    );
      </div>
